## Generated SDC file "OSDD_v2.sdc"

## Copyright (C) 1991-2016 Altera Corporation. All rights reserved.
## Your use of Altera Corporation's design tools, logic functions
## and other software and tools, and its AMPP partner logic
## functions, and any output files from any of the foregoing
## (including device programming or simulation files), and any
## associated documentation or information are expressly subject
## to the terms and conditions of the Altera Program License
## Subscription Agreement, the Altera Quartus Prime License Agreement,
## the Altera MegaCore Function License Agreement, or other
## applicable license agreement, including, without limitation,
## that your use is for the sole purpose of programming logic
## devices manufactured by Altera and sold by Altera or its
## authorized distributors.  Please refer to the applicable
## agreement for further details.


## VENDOR  "Altera"
## PROGRAM "Quartus Prime"
## VERSION "Version 16.0.2 Build 222 07/20/2016 SJ Standard Edition"

## DATE    "Thu Sep 19 14:42:02 2019"

##
## DEVICE  "5CGXFC5C6F27C7"
##

#**************************************************************
# Time Information
#**************************************************************
set_time_format -unit ns -decimal_places 3

#**************************************************************
# create clocks
#**************************************************************
create_clock -name CLK_LVDS_125_P -period 8 [get_ports {CLK_LVDS_125_P}]

#**************************************************************
# Recieve side FPGA RGMII
#**************************************************************
# Create a 125MHz clock
# virtual_source: an ideal clock in the sourcing device
# RX_CLK: input clock port of the interface; 90 deg phase shifted
create_clock -name virtual_source -period 8
create_clock -name ENETA_RX_CLK -period 8 -waveform { 2 6 } [get_ports {ENETA_RX_CLK}]

# Set input delay based on the requirements mentioned previously
# RX_CLK is 90 deg phase shifted
# Input delay is relative to the rising and falling edges of the clock
set_input_delay -max 0.8 -clock [get_clocks virtual_source] -add_delay [get_ports ENETA_RX_D*]
set_input_delay -min -0.8 -clock [get_clocks virtual_source] -add_delay [get_ports ENETA_RX_D*]
set_input_delay -max 0.8 -clock_fall -clock [get_clocks virtual_source] -add_delay [get_ports ENETA_RX_D*]
set_input_delay -min -0.8 -clock_fall -clock [get_clocks virtual_source] -add_delay [get_ports ENETA_RX_D*]

set_input_delay -max 0.8 -clock [get_clocks virtual_source] -add_delay [get_ports {ENETA_RX_DV}]
set_input_delay -min -0.8 -clock [get_clocks virtual_source] -add_delay [get_ports {ENETA_RX_DV}]
set_input_delay -max 0.8 -clock_fall -clock [get_clocks virtual_source] -add_delay [get_ports {ENETA_RX_DV}]
set_input_delay -min -0.8 -clock_fall -clock [get_clocks virtual_source] -add_delay [get_ports {ENETA_RX_DV}]

# Set false paths to remove irrelevant setup and hold analysis
set_false_path -fall_from [get_clocks virtual_source] -rise_to [get_clocks {ENETA_RX_CLK}] -setup
set_false_path -rise_from [get_clocks virtual_source] -fall_to [get_clocks {ENETA_RX_CLK}] -setup
set_false_path -fall_from [get_clocks virtual_source] -fall_to [get_clocks {ENETA_RX_CLK}] -hold
set_false_path -rise_from [get_clocks virtual_source] -rise_to [get_clocks {ENETA_RX_CLK}] -hold


#**************************************************************
# Transmit side FPGA RGMII
#**************************************************************
# Below are the pll derived clocks, which can also be generated by typing
# derive_pll_clocks in the TCL console
# Refer to the Quartus II TimeQuest Timing Analyzer chapter in Quartus II Handbook.
# create_generated_clock -name {outPLL|altpll_component|auto_generated|pll1|clk[0]} -source [get_pins {outPLL|altpll_component|auto_generated|pll1|inclk[0]}] -duty_cycle 50/1 -multiply_by 1 -master_clock {CLK_LVDS_125_P} [get_pins {outPLL|altpll_component|auto_generated|pll1|clk[0]}] 
# create_generated_clock -name {outPLL|altpll_component|auto_generated|pll1|clk[1]} -source [get_pins {outPLL|altpll_component|auto_generated|pll1|inclk[0]}] -duty_cycle 50/1 -multiply_by 1 -divide_by 5 -master_clock {CLK_LVDS_125_P} [get_pins {outPLL|altpll_component|auto_generated|pll1|clk[1]}] 
# create_generated_clock -name {outPLL|altpll_component|auto_generated|pll1|clk[2]} -source [get_pins {outPLL|altpll_component|auto_generated|pll1|inclk[0]}] -duty_cycle 50/1 -multiply_by 1 -divide_by 50 -master_clock {CLK_LVDS_125_P} [get_pins {outPLL|altpll_component|auto_generated|pll1|clk[2]}] 
# set_clock_groups -exclusive -group {outPLL|altpll_component|auto_generated|pll1|clk[0]} -group {outPLL|altpll_component|auto_generated|pll1|clk[1]} -group outPLL|altpll_component|auto_generated|pll1|clk[2]
# create_generated_clock -name tx_data_clock -source [get_pins {outPLL|altpll_component|auto_generated|pll1|clk[0]}]  [get_nets {i_eth0|fifoctl|read_clk}]

create_generated_clock -name tx_output_clock -source [get_ports {ENETA_RX_CLK}] [get_ports {ENETB_GTX_CLK}]

# Set output delay based on the requirements mentioned previously
set_output_delay -clock tx_output_clock -max -0.9 [get_ports ENETB_TX_D*]
set_output_delay -clock tx_output_clock -min -2.7 [get_ports ENETB_TX_D*] -add_delay
set_output_delay -clock tx_output_clock -clock_fall -max -0.9 [get_ports ENETB_TX_D*] -add_delay
set_output_delay -clock tx_output_clock -clock_fall -min -2.7 [get_ports ENETB_TX_D*] -add_delay
set_output_delay -clock tx_output_clock -max -0.9 [get_ports {ENETB_TX_EN}]
set_output_delay -clock tx_output_clock -min -2.7 [get_ports {ENETB_TX_EN}] -add_delay
set_output_delay -clock tx_output_clock -clock_fall -max -0.9 [get_ports {ENETB_TX_EN}] -add_delay
set_output_delay -clock tx_output_clock -clock_fall -min -2.7 [get_ports {ENETB_TX_EN}] -add_delay

# Set multicycle paths to align the launch edge with the latch edge
set_multicycle_path 0 -setup -end -rise_from [get_clocks ENETA_RX_CLK] -rise_to [get_clocks tx_output_clock]
set_multicycle_path 0 -setup -end -fall_from [get_clocks ENETA_RX_CLK] -fall_to [get_clocks tx_output_clock]
set_multicycle_path 1 -setup -end -rise_from [get_clocks ENETA_RX_CLK] -rise_to [get_clocks tx_output_clock]
set_multicycle_path 1 -setup -end -fall_from [get_clocks ENETA_RX_CLK] -fall_to [get_clocks tx_output_clock]
# Set false paths to remove irrelevant setup and hold analysis
set_false_path -fall_from [get_clocks ENETA_RX_CLK] -rise_to [get_clocks tx_output_clock] -setup
set_false_path -rise_from [get_clocks ENETA_RX_CLK] -fall_to [get_clocks tx_output_clock] -setup
set_false_path -fall_from [get_clocks ENETA_RX_CLK] -fall_to [get_clocks tx_output_clock] -hold
set_false_path -rise_from [get_clocks ENETA_RX_CLK] -rise_to [get_clocks tx_output_clock] -hold

#**************************************************************
# MDIO
#**************************************************************
create_generated_clock -name mdio_mdc -source [get_ports {CLK_LVDS_125_P}] -divide_by 50 [get_keepers  {OSDD_ethernet:i_eth0|OSDD_MDIO_interface:mdio_phy0|mdc}]
create_generated_clock -name ENET_MDC -source [get_keepers  {OSDD_ethernet:i_eth0|OSDD_MDIO_interface:mdio_phy0|mdc}]  [get_ports {ENET_MDC}]

set_input_delay -add_delay -max -clock [get_clocks {mdio_mdc}]  390.000 [get_ports {ENET_MDIO}]
set_input_delay -add_delay -min -clock [get_clocks {mdio_mdc}]  10.000 [get_ports {ENET_MDIO}]

set_output_delay -add_delay -max -clock [get_clocks {mdio_mdc}]  380.000 [get_ports {ENET_MDIO}]
set_output_delay -add_delay -min -clock [get_clocks {mdio_mdc}]  420.000 [get_ports {ENET_MDIO}]


set_false_path -from {ENET_MDIO} -to {OSDD_ethernet:i_eth0|OSDD_MDIO_interface:mdio_phy0|mdio_data_in[0]}
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_MDIO_interface:mdio_phy0|mdio_t} -to {ENET_MDIO}
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_MDIO_interface:mdio_phy0|mdio_o} -to {ENET_MDIO}


#**************************************************************
# Set False Path
#**************************************************************
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_control:control_phy0|speed_stat_phy_0_old[0]}
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_control:control_phy0|speed_stat_phy_0_old[1]}
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_control:control_phy0|speed_stat_phy_1_old[0]}
set_false_path -from {OSDD_ethernet:i_eth0|OSDD_control:control_phy0|speed_stat_phy_1_old[1]}

#set_false_path -from [get_clocks {CLK_LVDS_125_P}] -to [get_clocks {tx_data_clock}]

#set_false_path -from {OSDD_ethernet:i_eth0|OSDD_fifo_controller:fifoctl|speed_stat_phy_1_reg[0]}
#set_false_path -from {OSDD_ethernet:i_eth0|OSDD_fifo_controller:fifoctl|speed_stat_phy_1_reg[1]}
#set_false_path -from {OSDD_ethernet:i_eth0|OSDD_fifo_controller:fifoctl|speed_stat_phy_0_reg[0]}
#set_false_path -from {OSDD_ethernet:i_eth0|OSDD_fifo_controller:fifoctl|speed_stat_phy_0_reg[1]}

set_false_path -to [get_ports {ENET_MDC}]

set_false_path -to [get_ports {ENETB_GTX_CLK}]

set_false_path -to [get_ports {ENETA_RESETN}]
set_false_path -to [get_ports {ENETB_RESETN}]

set_false_path -from [get_ports {FPGA_RESETN}]

set_false_path -to [get_ports {USER_LED*}]

set_false_path -from [get_ports {ENETA_INTN}]
set_false_path -from [get_ports {ENETB_INTN}]
set_false_path -from [get_ports {CLK_LVDS_125_P}]

#**************************************************************
# clock uncertainty
#**************************************************************
derive_clock_uncertainty
derive_pll_clocks